---
title: "Maryland Poison Center (MPC) data -- stream of consciousness"
author: "Leah Jager"
date: "6/11/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r packages}
library(tidyverse)
library(pdftools)
```

### Reading in data from a single file: Allegany County, 2018

Do I want to use `pdf_data()` or `pdf_text()`?  Let's see what each does for my file.  First, using `pdf_text()`:
```{r}
myData <- pdf_text("Allegany County Statistical Report 2018.pdf")
myData
myData[[1]]

myData2 <- pdf_data("Allegany County Statistical Report 2018.pdf")
myData2
myData2[[1]]
```
Both options separate the text from the two pages of the file, which is ideal since I am initially only going to pull the data from the first page.  If I use `pdf_text()` I will have to split on the newline character in order to separate the rows of data, but with `pdf_data()` it is already split to the individual words.  I do want to keep lines of words together, such as "< 12 months", etc for the ages and "Healthcare Facility" for the site, but I think I can do this after `pdf_data()` by using the (x,y) location variables for the text boxes:
```{r}
pdfData <- pdf_data("Allegany County Statistical Report 2018.pdf")
p1Data <- pdfData[[1]]

lineData <- p1Data %>% 
  group_by(y) %>% 
  arrange(x, .by_group=TRUE) %>%
  summarize(line = paste(text, collapse=" "))

lineData
```

Now I still have the problem of the fact that there are really two columns worth of data on this page of the pdf, which is reflected in row 5 of this line data frame, where we see there are 529 total human exposures and 24 animal exposures, both recorded on the same line of the pdf:
```{r}
lineData[5,]
```

I wonder if I can first split the data into two groups by column, and then group by the y value:
```{r}
p1Data %>% group_by(x) %>% arrange(y, .by_group=TRUE) %>% as.data.frame()
```

The end of the first column is at y=258, so I will create a new column to designate left/right column.  Then I can group by this left/right column before grouping by y and summarizing by collapsing across x:
```{r}
p1Data <- p1Data %>%
  mutate(column=ifelse(x < 260, "Left", "Right"))

lineData <- p1Data %>% 
  group_by(column,y) %>% 
  arrange(x, .by_group=TRUE) %>%
  summarize(line = paste(text, collapse=" "))
```

This is looking really good!  However the header of the pdf is causing trouble, since it bridges the two columns.  It will be easier if I remove it, but first I want to extract the county name and the year:

```{r}
orderedData <- p1Data %>% arrange(y,x)
year <- orderedData$text[1]
county <- paste(orderedData$text[4:5],collapse=" ")
county = gsub(",","",county)
```

Now I will remove these header rows and split into two columns.  I want to remove the first 3 rows of the data, which occur up to position y=159.
```{r}
p1Data %>% group_by(y) %>% summarize(n=n())

p1Data <- p1Data %>% filter(y > 160)

lineData <- p1Data %>% 
  group_by(column,y) %>% 
  arrange(x, .by_group=TRUE) %>%
  summarize(line = paste(text, collapse=" "))

lineData %>% as.data.frame()
```

Now I don't think I actually want to collapse across all words in a row, I want to keep the last word as the value and the previous words as the variable name:

```{r}
groupedData <- p1Data %>% 
  group_by(column,y) %>% 
  arrange(x, .by_group=TRUE) %>%
  mutate(type = ifelse(x==max(x), "value", "name"))

countData <- groupedData %>% 
  group_by(column, y) %>%
  arrange(x, .by_group=TRUE) %>%
  summarize(variable = paste(text[type=="name"], collapse=" "), count=text[type=="value"])

countData %>% as.data.frame()

countData <- countData %>% filter(count != "Calls", count!="exposure", count!="Site", count!="Outcome")

myRow <- as.data.frame(t(as.numeric(countData$count)))
names(myRow) <- countData$variable
myRow$Year <- year
myRow$County <- county

myRow
```

Now to make this into a function that is given the pdf file and returns the row of data:

```{r}

#pdf.file <- "Allegany County Statistical Report 2018.pdf"

pdfMPC.page1 <- function(pdf.file) {
  require(dplyr)
  require(pdftools)
 
# read in the pdf document; select the first page 
pdfData <- pdf_data(pdf.file)
p1Data <- pdfData[[1]]

# get the year and country from the header
orderedData <- p1Data %>% arrange(y,x)
year <- orderedData$text[1]
county <- paste(orderedData$text[4:5],collapse=" ")
county = gsub(",","",county)

# remove the header
p1Data <- p1Data %>% filter(y > 160)

# create the column variable (Left/Right)
p1Data <- p1Data %>%
  mutate(column=ifelse(x < 260, "Left", "Right"))

# group the data by column and height on the page
# keep the last entry of that column/height as the value
# assign the remaining entries for that column/height the name
groupedData <- p1Data %>% 
  group_by(column,y) %>% 
  arrange(x, .by_group=TRUE) %>%
  mutate(type = ifelse(x==max(x), "value", "name"))

# collapse the entries for name together to create the variable name
# keep the value as the count
countData <- groupedData %>% 
  group_by(column, y) %>%
  arrange(x, .by_group=TRUE) %>%
  summarize(variable = paste(text[type=="name"], collapse=" "), count=text[type=="value"])

# remove the rows that aren't variables/counts
countData <- countData %>% filter(count != "Calls", count!="exposure", count!="Site", count!="Outcome")

# create the data frame for this county/date
myRow <- as.data.frame(t(as.numeric(countData$count)))
names(myRow) <- countData$variable
myRow$Year <- year
myRow$County <- county

return(myRow)
}
```

Try out this function on the original dataset and two more files:
```{r}
pdfMPC.page1("Allegany County Statistical Report 2018.pdf")
pdfMPC.page1("Prince Georges County Statistical Report 2018.pdf")
pdfMPC.page1("Talbot County Statistical Report 2018.pdf")
```

I get warnings with both of these additional files.  I expected the issue with Price George's County, because there is an additional note at the top that reads "NOTE: This report reflects only the calls to the Maryland Poison Center from Prince Georges County. For complete statistics regarding Prince Georges County, statistics from the National Capitol Poison Center should also be consulted." I am surprise this happed with Talbot, since at a glad the structure of the file looks the same.  But the location data must not actually be the same, and this is the issue with hard coding amounts to determine the header and columns.  I need to look at both of these pdfs through `pdf_data()` to see how different they look.

```{r}
pgData <- pdf_data("Prince Georges County Statistical Report 2018.pdf")[[1]]
tData <- pdf_data("Talbot County Statistical Report 2018.pdf")[[1]]
aData <- pdf_data("Allegany County Statistical Report 2018.pdf")[[1]]
```

First I will check where the columns divide for these three files.  For Allegany County it was x=258, so I cut at x<260 to divide into columns.  
```{r}
aData %>% group_by(x) %>% arrange(y, .by_group=TRUE) %>% as.data.frame()
pgData %>% group_by(x) %>% arrange(y, .by_group=TRUE) %>% as.data.frame()
tData %>% group_by(x) %>% arrange(y, .by_group=TRUE) %>% as.data.frame()
```

It appears to be the same place for each of these two files.  Additionally, the next x values for these three files is 266, 265, and 266, respectively.  (PG county is a little different because of the additional note at the top.)  Cutting at x<260 is reasonable.

Now I will check where the header divides for these three files.  For Allegany County it was at y=159, so I cut at y > 160.
```{r}
aData %>% group_by(y) %>% summarize(n=n())
pgData %>% group_by(y) %>% summarize(n=n())
tData %>% group_by(y) %>% summarize(n=n())
```

The header ends at 159 for Allegany, with the next row at 187.  For PG County, the header ends at 199, with the next row at 227.  For Talbot, the header ends at 164, with the next row at 192.

For Allegany and Talbot, there is a slight spacing difference that could be fixed by cutting lower down in the document, say y > 175.  For PG County (and Montgomery County, which has a similar note), the cut needs to be more specific to these documents.

I think it makes more sense to cut after the 3rd line (whatever y-value that line may have) for all but the two different counties, and then cut after the 6th line for these two counties specifically.  This is better than hard coding y-values for cutting, which may differ with slight changes in spacing (single vs. double space, etc).  I should probably do this for deciding the columns as well, but I'm not going to worry about that now.

```{r}
y.cut <- aData %>% 
  group_by(y) %>% 
  arrange(y) %>% 
  summarize(n=n()) %>% 
  slice(3) %>% 
  select(y) %>% 
  as.numeric()

y.cut

y.cut <- pgData %>% 
  group_by(y) %>% 
  arrange(y) %>% 
  summarize(n=n()) %>% 
  slice(6) %>% 
  select(y) %>% 
  as.numeric()

y.cut
```

So my updated function is:

```{r}
pdfMPC.page1 <- function(pdf.file) {
  require(dplyr)
  require(pdftools)
 
# read in the pdf document; select the first page 
pdfData <- pdf_data(pdf.file)
p1Data <- pdfData[[1]]

# get the year and country from the header
orderedData <- p1Data %>% arrange(y,x)
year <- orderedData$text[1]
county <- paste(orderedData$text[4:5],collapse=" ")
county = gsub(",","",county)

# remove the header 
# the first 3 lines for most, the first 6 lines for PG and M counties
if (county=="Prince Georges County" | county=="Montgomery County") {
  y.cut <- p1Data %>% group_by(y) %>% arrange(y) %>% summarize(n=n()) %>%
    slice(6) %>% select(y) %>% as.numeric()
  p1Data <- p1Data %>% filter(y > y.cut + 1)
} else {
  y.cut <- p1Data %>% group_by(y) %>% arrange(y) %>% summarize(n=n()) %>%
    slice(3) %>% select(y) %>% as.numeric()
  p1Data <- p1Data %>% filter(y > y.cut + 1)
}

# create the column variable (Left/Right)
p1Data <- p1Data %>%
  mutate(column=ifelse(x < 260, "Left", "Right"))

# group the data by column and height on the page
# keep the last entry of that column/height as the value
# assign the remaining entries for that column/height the name
groupedData <- p1Data %>% 
  group_by(column,y) %>% 
  arrange(x, .by_group=TRUE) %>%
  mutate(type = ifelse(x==max(x), "value", "name"))

# collapse the entries for name together to create the variable name
# keep the value as the count
countData <- groupedData %>% 
  group_by(column, y) %>%
  arrange(x, .by_group=TRUE) %>%
  summarize(variable = paste(text[type=="name"], collapse=" "), count=text[type=="value"])

# remove the rows that aren't variables/counts
countData <- countData %>% filter(count != "Calls", count!="exposure", count!="Site", count!="Outcome")

# create the data frame for this county/date
myRow <- as.data.frame(t(as.numeric(countData$count)))
names(myRow) <- countData$variable
myRow$Year <- year
myRow$County <- county

return(myRow)
}
```

Try out this function on these three files:
```{r}
pdfMPC.page1("Allegany County Statistical Report 2018.pdf")
pdfMPC.page1("Prince Georges County Statistical Report 2018.pdf")
pdfMPC.page1("Talbot County Statistical Report 2018.pdf")
```

Still not quite working, because the county name for PG County has three words, not two.  This will be true for 4 of the counties, so need to re-write the part that assigns the county name.  I'm going to collapse the whole row, which will include the ", MD" part.
```{r}
year <- pgData %>% arrange(y,x) %>% slice(1) %>% select(text) %>% as.numeric()

county <- pgData %>% group_by(y) %>%
  arrange(x, .by_group=TRUE) %>% 
  summarize(line = paste(text, collapse=" ")) %>%
  slice(2) %>% select(line) %>% as.character()
```

Now, again, my updated function becomes:
```{r finalFunction}
pdfMPC.page1 <- function(pdf.file) {
  require(dplyr)
  require(pdftools)
 
# read in the pdf document; select the first page 
pdfData <- pdf_data(pdf.file)
p1Data <- pdfData[[1]]

# get the year and country from the header
year <- p1Data %>% arrange(y,x) %>% slice(1) %>% select(text) %>% as.numeric()

county <- p1Data %>% group_by(y) %>%
  arrange(x, .by_group=TRUE) %>% 
  summarize(line = paste(text, collapse=" ")) %>%
  slice(2) %>% select(line) %>% as.character()

# remove the header 
# the first 3 lines for most, the first 6 lines for PG and M counties
if (county=="Prince Georges County, MD" | county=="Montgomery County, MD") {
  y.cut <- p1Data %>% group_by(y) %>% arrange(y) %>% summarize(n=n()) %>%
    slice(6) %>% select(y) %>% as.numeric()
  p1Data <- p1Data %>% filter(y > y.cut + 1)
} else {
  y.cut <- p1Data %>% group_by(y) %>% arrange(y) %>% summarize(n=n()) %>%
    slice(3) %>% select(y) %>% as.numeric()
  p1Data <- p1Data %>% filter(y > y.cut + 1)
}

# create the column variable (Left/Right)
p1Data <- p1Data %>%
  mutate(column=ifelse(x < 260, "Left", "Right"))

# group the data by column and height on the page
# keep the last entry of that column/height as the value
# assign the remaining entries for that column/height the name
groupedData <- p1Data %>% 
  group_by(column,y) %>% 
  arrange(x, .by_group=TRUE) %>%
  mutate(type = ifelse(x==max(x), "value", "name"))

# collapse the entries for name together to create the variable name
# keep the value as the count
countData <- groupedData %>% 
  group_by(column, y) %>%
  arrange(x, .by_group=TRUE) %>%
  summarize(variable = paste(text[type=="name"], collapse=" "), count=text[type=="value"])

# remove the rows that aren't variables/counts
countData <- countData %>% filter(count != "Calls", count!="exposure", count!="Site", count!="Outcome")

# create the data frame for this county/date
myRow <- as.data.frame(t(as.numeric(countData$count)))
names(myRow) <- countData$variable
myRow$Year <- year
myRow$County <- county

return(myRow)
}
```

Try out this function on these three files:
```{r}
pdfMPC.page1("Allegany County Statistical Report 2018.pdf")
pdfMPC.page1("Prince Georges County Statistical Report 2018.pdf")
pdfMPC.page1("Talbot County Statistical Report 2018.pdf")
```

Now merge these files together into a single data frame:
```{r}
d1 <- pdfMPC.page1("Allegany County Statistical Report 2018.pdf")
d2 <- pdfMPC.page1("Prince Georges County Statistical Report 2018.pdf")
d3 <- pdfMPC.page1("Talbot County Statistical Report 2018.pdf")

dim(d1)
dim(d2)
dim(d3)

myData <- bind_rows(d1,d2,d3)
dim(myData)
names(myData)
myData$`Contamination/Tampering`
myData$`Contamination/tampering`
```

We can see that there are a couple of variable names that don't match perfectly between the different files: in one file, the names is "Contamination/tampering" and in the other it is "Contamination/Tampering."  And each of the three files is different for the Unknown/Other reason for exposure: "Other/Unknown", "Unknown Reason", "Unknown/Other"

I figure that these same types of issues will happen for other variable names in other files, so I think this is something to address while processing after merging.  The `bind_rows()` function will make sure it takes all of these and will put in `NA` where appropriate, so I will clean this after!

### Reading in the data from urls

The url links have the form:
https://www.mdpoison.com/media/SOP/mdpoisoncom/factsandreports/reports/countypdf2018/Allegany%20County%20Statistical%20Report%202018.pdf

This in general looks like:
https://www.mdpoison.com/media/SOP/mdpoisoncom/factsandreports/reports/countypdf**year**/**County%20Name%20**Statistical%20Report%20**year**.pdf

where **County%20Name%20** is the name of the county with %20 as spaces and **year** is the year of the data.  County names with punctuation (periods, apostrophes) drop the punctuation in the link name. 

We can go back through 2006; reports prior to 2006 have a different format so we will skip them for now.  (There are only two additional years, 2004 and 2005, and the format is very different, so may not be worth even trying to add to the data set.) 

We also need the names of the pdf files themselves to download from the web.  These are of the form:
"Allegany County Statistical Report 2018.pdf"

The 2016 links are a little bit different:
https://www.mdpoison.com/media/SOP/mdpoisoncom/factsandreports/reports/**county-pdf-2016**/Allegany%20County%20Statistical%20Report%202016.pdf

so will have to account for that

Here we set up the counties and years we need to read in:
```{r}
countyNames <- c("Allegany County", "Anne Arundel County", "Baltimore City", "Baltimore County", "Calvert County", "Caroline County", "Carroll County", "Cecil County", "Charles County", "Dorchester County", "Frederick County", "Garrett County", "Harford County", "Howard County", "Kent County", "Montgomery County", "Prince Georges County", "Queen Annes County", "Somerset County", "St Marys County", "Talbot County", "Washington County", "Wicomico County", "Worcester County")

years <- 2006:2018
```

Now we create all of the links for each county/year combination:
```{r}
links <- NULL
files <- NULL
for (i in years) {
  for (j in countyNames) {
    countyNameForLink <- paste(unlist(strsplit(j, " ")), collapse="%20")
    if (i != 2016) {
      tempLink <- paste0("https://www.mdpoison.com/media/SOP/mdpoisoncom/factsandreports/reports/countypdf",i,"/",countyNameForLink,"%20Statistical%20Report%20",i,".pdf")} else {
      tempLink <- paste0("https://www.mdpoison.com/media/SOP/mdpoisoncom/factsandreports/reports/county-pdf-",i,"/",countyNameForLink,"%20Statistical%20Report%20",i,".pdf")}
    tempFile <- paste0(j," Statistical Report ", i,".pdf")
    links <- c(links, tempLink)
    files <- c(files, tempFile)
  }
}
```

I am going to download these to a subfolder in my directory and not upload to Github.  So first I will create a data subfolder and then change the work the subdirectory to the file names and then try downloading a file:
```{r}
download.file(links[1], paste0("./data/",files[1]))
```

Now to download them all:
```{r}
length(links)
for (i in 1:length(links)) {
  download.file(links[i], paste0("./data/",files[i]))
}
```

I should have 312 files in my folder now; I confirmed this!

Now I will put each one of these files through my pdf function and merge them together!  *fingers crossed*

```{r}

d1 <- pdfMPC.page1(paste0("./data/",files[1]))
myData <- d1

options(warn=2)
for (i in 2:length(files)) {
  di <- pdfMPC.page1(paste0("./data/",files[i]))
  myData <- bind_rows(myData,di)
  print(i)
}

dim(myData)
names(myData)
sort(names(myData))
```

Need to trouble shoot some particular files:

Notes:

(1) Had to modify to remove commas from counts: 5,321 to 5321 (Baltimore County 2006)
(2) Had to modify to account for blank counts; for now I am setting those to 0.  Should probably set them to NA? This also required me to modify how labeling the name and the value, since this row only had a name not a value. (Somerset 2006)
(3) Some files have "Maryland Poison Center" printed at bottom of page 1, need to remove this (Cecil 2007)
(4) I think because of the apostrophe maybe, it's saying part of the header is actually two different heights, so it's split it into 2 pieces, which means I can't cut after 3rd line, really need to cut after 4th. Make a special case for this one file.(Queen Annes 2011)
(5) Same issue as for Queen Annes, just included it in the exception  (St Marys 2011)

```{r updateFunction}

pdf.file <- paste0("./data/",files[140])
pdfMPC.page1 <- function(pdf.file) {
  require(dplyr)
  require(pdftools)
 
# read in the pdf document; select the first page 
pdfData <- pdf_data(pdf.file)
p1Data <- pdfData[[1]]

# get the year and country from the header
year <- p1Data %>% arrange(y,x) %>% slice(1) %>% select(text) %>% as.numeric()

county <- p1Data %>% group_by(y) %>%
  arrange(x, .by_group=TRUE) %>% 
  summarize(line = paste(text, collapse=" ")) %>%
  slice(2) %>% select(line) %>% as.character()

# remove the header 
# the first 3 lines for most, the first 6 lines for PG and M counties
if (county=="Prince Georges County, MD" | county=="Montgomery County, MD") {
  y.cut <- p1Data %>% group_by(y) %>% arrange(y) %>% summarize(n=n()) %>%
    slice(6) %>% select(y) %>% as.numeric()
  p1Data <- p1Data %>% filter(y > y.cut + 1)
} else {
  if (county=="Queen Anne’s" | county=="St. Mary’s") {
      y.cut <- p1Data %>% group_by(y) %>% arrange(y) %>% summarize(n=n()) %>%
    slice(4) %>% select(y) %>% as.numeric()
  p1Data <- p1Data %>% filter(y > y.cut + 1)
  county <- paste0(county," County, MD")
  } else {
    y.cut <- p1Data %>% group_by(y) %>% arrange(y) %>%
      summarize(n=n()) %>%
      slice(3) %>% select(y) %>% as.numeric()
    p1Data <- p1Data %>% filter(y > y.cut + 1)
  }
}

# create the column variable (Left/Right)
p1Data <- p1Data %>%
  mutate(column=ifelse(x < 265, "Left", "Right"))

# group the data by column and height on the page
# keep the last entry of that column/height as the value
# assign the remaining entries for that column/height the name
groupedData <- p1Data %>% 
  group_by(column,y) %>% 
  arrange(x, .by_group=TRUE) %>%
  mutate(type = ifelse(x==max(x) & x==min(x), "name", ifelse(x==max(x), "value", "name")))

# collapse the entries for name together to create the variable name
# keep the value as the count
countData <- groupedData %>% 
  group_by(column, y) %>%
  arrange(x, .by_group=TRUE) %>%
  summarize(variable = paste(text[type=="name"], collapse=" "), count=ifelse(is_empty(text[type=="value"])==FALSE, text[type=="value"],"0"))

# remove the rows that aren't variables/counts
countData <- countData %>% filter(count != "Calls", count!="exposure", count!="Site", count!="Outcome", count!="Center", variable!="Maryland")

# create the data frame for this county/date
myRow <- as.data.frame(t(as.numeric(gsub(",","",countData$count))))
names(myRow) <- countData$variable
myRow$Year <- year
myRow$County <- county

return(myRow)
}
```

The above function now works for all the files!  I am going to need to find a way to identify which "Unknown" and "Others" go with which subcategories, since it's impossible to tell just from the combined files.  Maybe can use the indenting to do this?  Then will have to do some major data cleaning for all the slightly different variations on the names of categories.  

```{r}
names(myData)
myNames <- data.frame(names=names(myData))
myNames %>% arrange(names)
```

First I am going to assign higher categories to help sort out which group the other's/unknowns come from:

The higher categories are:
Left column:
Total human exposures to Reason for exposure, give subcategory "Age:"
Unintentional to Intentional, give subcategory "RFE-Unintent:"
Intentional to Other, give subcategory "RFE-Intent:"
Other to end, give subcategory "RFE-Other:"

Right column: 
Management Site to Medical Outcome, give subcategory "MS"
Medical outcome to end, give subcategory "MO"


```{r updateFunctionSubCats}

pdf.file <- paste0("./data/",files[148])
pdfMPC.page1 <- function(pdf.file) {
  require(dplyr)
  require(pdftools)
 
# read in the pdf document; select the first page 
pdfData <- pdf_data(pdf.file)
p1Data <- pdfData[[1]]

# get the year and country from the header
year <- p1Data %>% arrange(y,x) %>% slice(1) %>% select(text) %>% as.numeric()

county <- p1Data %>% group_by(y) %>%
  arrange(x, .by_group=TRUE) %>% 
  summarize(line = paste(text, collapse=" ")) %>%
  slice(2) %>% select(line) %>% as.character()

# remove the header 
# the first 3 lines for most, the first 6 lines for PG and M counties
if (county=="Prince Georges County, MD" | county=="Montgomery County, MD") {
  y.cut <- p1Data %>% group_by(y) %>% arrange(y) %>% summarize(n=n()) %>%
    slice(6) %>% select(y) %>% as.numeric()
  p1Data <- p1Data %>% filter(y > y.cut + 1)
} else {
  if (county=="Queen Anne’s" | county=="St. Mary’s") {
      y.cut <- p1Data %>% group_by(y) %>% arrange(y) %>% summarize(n=n()) %>%
    slice(4) %>% select(y) %>% as.numeric()
  p1Data <- p1Data %>% filter(y > y.cut + 1)
  county <- paste0(county," County, MD")
  } else {
    y.cut <- p1Data %>% group_by(y) %>% arrange(y) %>%
      summarize(n=n()) %>%
      slice(3) %>% select(y) %>% as.numeric()
    p1Data <- p1Data %>% filter(y > y.cut + 1)
  }
}

# create the column variable (Left/Right)
p1Data <- p1Data %>%
  mutate(column=ifelse(x < 265, "Left", "Right"))

# group the data by column and height on the page
# keep the last entry of that column/height as the value
# assign the remaining entries for that column/height the name
groupedData <- p1Data %>% 
  group_by(column,y) %>% 
  arrange(x, .by_group=TRUE) %>%
  mutate(type = ifelse(x==max(x) & x==min(x), "name", ifelse(x==max(x), "value", "name")))

# collapse the entries for name together to create the variable name
# keep the value as the count
countData <- groupedData %>% 
  group_by(column, y) %>%
  arrange(x, .by_group=TRUE) %>%
  summarize(variable = paste(text[type=="name"], collapse=" "), count=ifelse(is_empty(text[type=="value"])==FALSE, text[type=="value"],"0"), xmin=min(x))


y.age.min <- countData$y[countData$variable=="Total human exposures"]
y.age.max <- countData$y[countData$variable=="Reason for"]
y.un.min <- countData$y[countData$variable=="Unintentional"]
y.un.max <- countData$y[countData$variable=="Intentional"]
y.int.min <- countData$y[countData$variable=="Intentional"]
x.min <- min(countData$xmin[countData$column=="Left"])
y.int.max <- countData$y[countData$column=="Left" & countData$variable=="Other" & countData$xmin==x.min]
y.other.min <- countData$y[countData$column=="Left" & countData$variable=="Other" & countData$xmin==x.min]

y.ms.min <- countData$y[countData$variable=="Management"]
y.ms.max <- countData$y[countData$variable=="Medical"]
y.mo.min <- countData$y[countData$variable=="Medical"]

countData <- countData %>%
  mutate(variableSub=ifelse(column=="Left" & y > y.age.min & y < y.age.max, "Age:",
         ifelse(column=="Left" & y > y.un.min & y < y.un.max, "ReasonUn:",
         ifelse(column=="Left" & y > y.int.min & y < y.int.max, "ReasonInt:",
         ifelse(column=="Left" & y > y.other.min, "ReasonOther:",
         ifelse(column=="Right" & y > y.ms.min & y < y.ms.max, "MS:",
         ifelse(column=="Right" & y > y.mo.min, "MO:", "")))))))

# remove the rows that aren't variables/counts
countData <- countData %>% filter(count != "Calls", count!="exposure", count!="Site", count!="Outcome", count!="Center", variable!="Maryland")

countData <- countData %>%
  mutate(name=paste0(variableSub, variable))

# create the data frame for this county/date
myRow <- as.data.frame(t(as.numeric(gsub(",","",countData$count))))
names(myRow) <- countData$name
myRow$Year <- year
myRow$County <- county

return(myRow)
}
```

```{r}

d1 <- pdfMPC.page1(paste0("./data/",files[1]))
myData <- d1

options(warn=2)
for (i in 2:length(files)) {
  di <- pdfMPC.page1(paste0("./data/",files[i]))
  myData <- bind_rows(myData,di)
  print(i)
}

dim(myData)
names(myData)
```

Now have to fix some issues with this new update when it breaks for some counties/years

(1) Baltimore County 2012; there is an "Other" listing in addition to the "Other" subcategory in the left column.  Don't just want to choose the first one, because what if the "Other" listing falls above for another county.  Going to use the indentation by keeping track of the minimum x value when I collapse; this will designate the difference between the subcategory and just a listing

Well, it worked, but now I actually have MORE additional columns, and some of the sub-columns are now labeled with NA instead of the appropriate subcategory.

```{r updateFunctionSubCats}

pdf.file <- paste0("./data/",files[241])
pdfMPC.page1 <- function(pdf.file, i) {
  require(dplyr)
  require(pdftools)
 
# read in the pdf document; select the first page 
pdfData <- pdf_data(pdf.file)
p1Data <- pdfData[[1]]

# get the year and country from the header
year <- p1Data %>% arrange(y,x) %>% slice(1) %>% select(text) %>% as.numeric()

county <- p1Data %>% group_by(y) %>%
  arrange(x, .by_group=TRUE) %>% 
  summarize(line = paste(text, collapse=" ")) %>%
  slice(2) %>% select(line) %>% as.character()

# remove the header 
# the first 3 lines for most, the first 6 lines for PG and M counties
if (county=="Prince Georges County, MD" | county=="Montgomery County, MD") {
  y.cut <- p1Data %>% group_by(y) %>% arrange(y) %>% summarize(n=n()) %>%
    slice(6) %>% select(y) %>% as.numeric()
  p1Data <- p1Data %>% filter(y > y.cut + 1)
} else {
  if (county=="Queen Anne’s" | county=="St. Mary’s") {
      y.cut <- p1Data %>% group_by(y) %>% arrange(y) %>% summarize(n=n()) %>%
    slice(4) %>% select(y) %>% as.numeric()
  p1Data <- p1Data %>% filter(y > y.cut + 1)
  county <- paste0(county," County, MD")
  } else {
    y.cut <- p1Data %>% group_by(y) %>% arrange(y) %>%
      summarize(n=n()) %>%
      slice(3) %>% select(y) %>% as.numeric()
    p1Data <- p1Data %>% filter(y > y.cut + 1)
  }
}

# create the column variable (Left/Right)
p1Data <- p1Data %>%
  mutate(column=ifelse(x < 265, "Left", "Right"))

# group the data by column and height on the page
# keep the last entry of that column/height as the value
# assign the remaining entries for that column/height the name
groupedData <- p1Data %>% 
  group_by(column,y) %>% 
  arrange(x, .by_group=TRUE) %>%
  mutate(type = ifelse(x==max(x) & x==min(x), "name", ifelse(x==max(x), "value", "name")))

# collapse the entries for name together to create the variable name
# keep the value as the count
countData <- groupedData %>% 
  group_by(column, y) %>%
  arrange(x, .by_group=TRUE) %>%
  summarize(variable = paste(text[type=="name"], collapse=" "), count=ifelse(is_empty(text[type=="value"])==FALSE, text[type=="value"],"0"), xmin=min(x))

# remove the any variables/counts that include any part of "Maryland Center"
countData <- countData %>% filter(count != "Maryland", count!="Center",  variable!="Maryland", variable!="Center", variable!="Types of", variable!="Reason for")

## Designate the "Other Reason" variable to say "Other Reason"
countData$variable[countData$variable=="Other" & countData$xmin==min(countData$xmin)] <- "Other Reason"

y.age.min <- countData$y[countData$variable=="Total human exposures"]
y.age.max <- countData$y[countData$variable=="Unintentional"]
y.un.min <- countData$y[countData$variable=="Unintentional"]
y.un.max <- countData$y[countData$variable=="Intentional"]
y.int.min <- countData$y[countData$variable=="Intentional"]
y.int.max <- countData$y[countData$variable=="Other Reason"]
y.other.min <- countData$y[countData$variable=="Other Reason"]

y.ms.min <- countData$y[countData$variable=="Management"]
y.ms.max <- countData$y[countData$variable=="Medical"]
y.mo.min <- countData$y[countData$variable=="Medical"]

countData <- countData %>%
  mutate(variableSub=ifelse(column=="Left" & y > y.age.min & y < y.age.max, "Age:",
         ifelse(column=="Left" & y > y.un.min & y < y.un.max, "Unintentional:",
         ifelse(column=="Left" & y > y.int.min & y < y.int.max, "Intentional:",
         ifelse(column=="Left" & y > y.other.min, "Other:",
         ifelse(column=="Right" & y > y.ms.min & y < y.ms.max, "ManageSite:",
         ifelse(column=="Right" & y > y.mo.min, "MedOutcome:", "")))))))

# remove the rows that aren't variables/counts
countData <- countData %>% filter(count != "Calls", count!="exposure", count!="Site", count!="Outcome", variable!="Medical", variable!="Outcome")

countData <- countData %>%
  mutate(name=paste0(variableSub, variable))

# create the data frame for this county/date
myRow <- as.data.frame(t(as.numeric(gsub(",","",countData$count))))
names(myRow) <- countData$name
myRow$Year <- year
myRow$County <- county
myRow$fileNo <- i #to help diagnose

return(myRow)
}
```


```{r}

d1 <- pdfMPC.page1(paste0("./data/",files[1]),1)
myData <- d1

options(warn=2)
for (i in 2:length(files)) {
  di <- pdfMPC.page1(paste0("./data/",files[i]),i)
  myData <- bind_rows(myData,di)
  print(i)
}

dim(myData)
names(myData)

#myData %>% filter(!is.na(NACenter)) %>% select(fileNo)
#myData %>% filter(!is.na(`ReasonOther:Maryland`)) %>% select(fileNo)
#myData %>% filter(!is.na(`NATotal human exposures`)) %>% select(fileNo)
#myData %>% filter(!is.na(Medical)) %>% select(fileNo)
```

(1) Somerset Count 2008, the row giving the % of calls runs onto a second line
(2) 3 counties/years have "Maryland Poison Center" at bottom of first page of pdf
(3) LOTS of counties had issues with the indentation of "Types of calls" and "Reason for exposure" that caused issues with designating the "Other Reason category based on indenting"  Removed these columns first before doing the rest.
(4) Weird spacing for "Medical Outcome" for Calvert 2017


Now just a matter of cleaning up typos!  Need to do this carefully to be sure I'm combining things sensibly!
```{r}
sort(names(myData))

# Age recoding
### Unknown
pairs(~`Age:Unknown` + `Age:Unknown age` + `Age:Unknown Age`, data=myData )
myData <- myData %>% 
  mutate(`Age:Unknown`=ifelse(!is.na(`Age:Unknown`), `Age:Unknown`, `Age:Unknown age`)) %>% select(-`Age:Unknown age`) %>%
  mutate(`Age:Unknown`=ifelse(!is.na(`Age:Unknown`), `Age:Unknown`, `Age:Unknown Age`)) %>% select(-`Age:Unknown Age`)
### Unknown Adult (without age specified)
pairs(~`Age:Unknown adult` + `Age:Unknown Adult`, data=myData )
myData <- myData %>% 
  mutate(`Age:Unknown adult`=ifelse(!is.na(`Age:Unknown adult`), `Age:Unknown adult`, `Age:Unknown Adult`)) %>% select(-`Age:Unknown Adult`)

# Management Site recoding
### Other/Unknown
pairs(~`ManageSite:Other/Unknown` + `ManageSite:Other/unknown` + `ManageSite:Other` + `ManageSite:Unknown` , data=myData )
myData <- myData %>% rowwise() %>% mutate(`ManageSite:temp`=ifelse(!is.na(`ManageSite:Other`) | !is.na(`ManageSite:Unknown`), sum(`ManageSite:Other`,`ManageSite:Unknown`, na.rm=TRUE),NA)) %>% select(-`ManageSite:Other`, -`ManageSite:Unknown`)
pairs(~`ManageSite:Other/Unknown` + `ManageSite:Other/unknown` +`ManageSite:temp` , data=myData )
myData <- myData %>% 
  mutate(`ManageSite:Other/Unknown`=ifelse(!is.na(`ManageSite:Other/Unknown`), `ManageSite:Other/Unknown`, `ManageSite:Other/unknown`)) %>% select(-`ManageSite:Other/unknown`) %>%
  mutate(`ManageSite:Other/Unknown`=ifelse(!is.na(`ManageSite:Other/Unknown`), `ManageSite:Other/Unknown`, `ManageSite:temp`)) %>% select(-`ManageSite:temp`)

# Other Reason recoding
### Contamination/Tampering
pairs(~`Other:Contamination/Tampering` + `Other:Contamination/tampering`, data=myData )
myData <- myData %>% 
  mutate(`Other:Contamination/Tampering`=ifelse(!is.na(`Other:Contamination/Tampering`), `Other:Contamination/Tampering`, `Other:Contamination/tampering`)) %>% select(-`Other:Contamination/tampering`)
### Other/Unknown
pairs(~`Other:Other/Unknown` + `Other:Other`+ `Other:Other?Unknown` + `Other:Other/Unknown Reason` + `Other:Unknown`+ `Other:Unknown Reason`+ `Other:Unknown/Other`, data=myData )
myData <- myData %>% rowwise() %>% mutate(`Other:temp`=ifelse(!is.na(`Other:Other`) | !is.na(`Other:Unknown`), sum(`Other:Other`,`Other:Unknown`, na.rm=TRUE),NA)) %>% select(-`Other:Other`, -`Other:Unknown`)
pairs(~`Other:Other/Unknown` + `Other:temp`+ `Other:Other?Unknown` + `Other:Other/Unknown Reason` + `Other:Unknown Reason`+ `Other:Unknown/Other`, data=myData )
myData <- myData %>% 
  mutate(`Other:Other/Unknown`=ifelse(!is.na(`Other:Other/Unknown`), `Other:Other/Unknown`, `Other:temp`)) %>% select(-`Other:temp`) %>%
  mutate(`Other:Other/Unknown`=ifelse(!is.na(`Other:Other/Unknown`), `Other:Other/Unknown`, `Other:Other?Unknown`)) %>% select(-`Other:Other?Unknown`) %>% 
  mutate(`Other:Other/Unknown`=ifelse(!is.na(`Other:Other/Unknown`), `Other:Other/Unknown`, `Other:Other/Unknown Reason`)) %>% select(-`Other:Other/Unknown Reason`) %>% 
  mutate(`Other:Other/Unknown`=ifelse(!is.na(`Other:Other/Unknown`), `Other:Other/Unknown`, `Other:Unknown Reason`)) %>% select(-`Other:Unknown Reason`) %>% 
  mutate(`Other:Other/Unknown`=ifelse(!is.na(`Other:Other/Unknown`), `Other:Other/Unknown`, `Other:Unknown/Other`)) %>% select(-`Other:Unknown/Other`)

# Unintentional recoding
### Bite or sting
pairs(~`Unintentional:Bite or sting` + `Unintentional:Bite or Sting`, data=myData )
myData <- myData %>% 
  mutate(`Unintentional:Bite or sting`=ifelse(!is.na(`Unintentional:Bite or sting`), `Unintentional:Bite or sting`, `Unintentional:Bite or Sting`)) %>% select(-`Unintentional:Bite or Sting`)
### Food poisoning
pairs(~`Unintentional:Food poisoning` + `Unintentional:Food Poisoning`, data=myData )
myData <- myData %>% 
  mutate(`Unintentional:Food poisoning`=ifelse(!is.na(`Unintentional:Food poisoning`), `Unintentional:Food poisoning`, `Unintentional:Food Poisoning`)) %>% select(-`Unintentional:Food Poisoning`)
###Other/Unknown
pairs(~`Unintentional:Other/Unknown` + `Unintentional:Unkknown` + `Unintentional:Unknown`, data=myData )
myData <- myData %>% 
  mutate(`Unintentional:Other/Unknown`=ifelse(!is.na(`Unintentional:Other/Unknown`), `Unintentional:Other/Unknown`, `Unintentional:Unkknown`)) %>% select(-`Unintentional:Unkknown`) %>%
  mutate(`Unintentional:Other/Unknown`=ifelse(!is.na(`Unintentional:Other/Unknown`), `Unintentional:Other/Unknown`, `Unintentional:Unknown`)) %>% select(-`Unintentional:Unknown`)

sort(names(myData))
```

Finally, order the data in a meaningful way:
```{r}
myData <- myData %>%
  select(sort(names(myData)))

myData <- myData %>%
  select(fileNo, County, Year, `Total human exposures`, `Animal Exposures`, `Information Calls`, `Age:< 12 months`, `Age:1 year`, `Age:2 years`, `Age:3 years`, `Age:4 years`, `Age:5 years`, `Age:6-12 years`, `Age:13-19 years`, `Age:20-59 years`, `Age:>60 years`, everything())
```

Now write this data to a .csv file:
```{r}
write_csv(myData, "MPCdata.csv")
```

After perusing the .csv file, I think I can clean up the age variables a little bit more by collapsing into just an adult category and then an unknown category and unknown child category
```{r}
names(myData)

myData %>% filter(!is.na(`Age:<60 years`))
#After looking at the pdfs for Caroline County for 2010+, this is clearly a typo that should read `Age:>60 years`
pairs(~`Age:>60 years` + `Age:<60 years`, data=myData )
myData <- myData %>% 
  mutate(`Age:>60 years`=ifelse(!is.na(`Age:>60 years`), `Age:>60 years`, `Age:<60 years`)) %>% select(-`Age:<60 years`)

myData %>% filter(!is.na(`Age:Adult`)) %>% ungroup() %>% group_by(Year) %>% summarize(n=n())
myData %>% filter(!is.na(`Age:20-59 years`)) %>% ungroup() %>% group_by(Year) %>% summarize(n=n())
myData %>% filter(!is.na(`Age:>60 years`)) %>% ungroup() %>% group_by(Year) %>% summarize(n=n())
pairs(~`Age:>60 years` + `Age:Adult` + `Age:20-59 years`, data=myData )
#It's clear that the "Adult" category encompasses the 20-59 and >60 categories. From 2006-2009 they used the adult category.  From 2010 on, they started splitting adult into two groups. I will re-create this Adult category for all years and leave the smaller categories for the later years
myData <- myData %>% mutate(`Age:Adult`=ifelse(Year < 2010, `Age:Adult`, `Age:>60 years`+`Age:20-59 years`))


#Now have noticed a discrepancy with the years in that in 2014 there are 25 counties and in 2015 there are only 23
myData %>% filter(Year==2014) %>% select(County, Year, fileNo) %>% as.data.frame()
#It looks like Somerset is showing up twice
#file numbers 211 and 235

files[211]
files[235]

#The data files are in fact different (have different numbers) but both are labeled 2014 on the front of the document.  However, the one from the 2015 link is labeled 2015 on the 2nd page of the document, so I will assume this is a typo and assign this the year 2015 for fileNo235
myData$Year[myData$fileNo==235] <- 2015

#Finally check a few more age things
myData %>% filter(!is.na(`Age:Unknown`))%>% ungroup() %>% group_by(Year) %>% summarize(n=n()) 
myData %>% filter(!is.na(`Age:Unknown adult`))%>% ungroup() %>% group_by(Year) %>% summarize(n=n()) 
myData %>% filter(!is.na(`Age:Unknown child`))%>% ungroup() %>% group_by(Year) %>% summarize(n=n()) 
#I think this "Unknown Adult" should really be incorporated into the "Adult" category for these years 2010+, since they couldn't be put into an age range, but we do know they are adults.  But also keep this category separate
myData <- myData %>% mutate(`Age:Adult`=ifelse(Year < 2010, `Age:Adult`, 
                                               ifelse(!is.na(`Age:Unknown adult`),`Age:>60 years`+`Age:20-59 years` + `Age:Unknown adult`,
                                                      `Age:>60 years`+`Age:20-59 years`)))


```

Now write this data to a .csv file again:
```{r}
write_csv(myData, "MPCdata.csv")
```

Last this I want to do is make the names easier to work with (remove : and / and spaces):
```{r}
names(myData)
namesNew <- names(myData)
namesNew <- gsub(pattern=":",replacement="_", namesNew)
namesNew <- gsub(pattern=" or s",replacement="/S", namesNew)
namesNew <- gsub(pattern="/",replacement=".", namesNew)
namesNew <- gsub(pattern="<",replacement="Under", namesNew)
namesNew <- gsub(pattern=">",replacement="Over", namesNew)
namesNew <- gsub(pattern="years",replacement="yr", namesNew)
namesNew <- gsub(pattern="year",replacement="yr", namesNew)
namesNew <- gsub(pattern="months",replacement="mo", namesNew)
namesNew <- gsub(pattern=" p",replacement=" P", namesNew)
namesNew <- gsub(pattern=" s",replacement=" S", namesNew)
namesNew <- gsub(pattern=" a",replacement=" A", namesNew)
namesNew <- gsub(pattern=" c",replacement=" C", namesNew)
namesNew <- gsub(pattern="Site.non",replacement="Site.Non", namesNew)
namesNew <- gsub(pattern=" ",replacement="", namesNew)

names(myData) <- namesNew
```

Now write this data to a .csv file again:
```{r}
write_csv(myData, "MPCdata.csv")
```